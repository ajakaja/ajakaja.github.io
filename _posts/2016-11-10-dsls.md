---
layout: blog
title: "DSLs all the way down"
math: true
footnotes: true
excerpt_separator: <!--more-->
---

*[possibly interesting to: software engineers]*
*[epistemic status: I'm reasonably sure there's a good idea here. But there are lots of software techniques I don't know about, so maybe it's not interesting because it's not at all novel.]*

A [Domain-Specific Language](https://en.wikipedia.org/wiki/Domain-specific_language), or DSL, is a mini-programming language created for a specific purpose, rather than being generally useful for doing anything. HTML is the most well-known example: it's used to write webpages. It's not used to write servers or databases, because it's a declarative content organization language and it just can't really do that.

Now, here are two suggestive anecdotes about how software engineering is hard.

<!--more-->

## 1

Once upon a time, a friend and I embarked on a journey to write a little video game (in Java, because that's what we knew best). It was going to be a simple little RPG, with combat, exploration, dialogue, AI, etc. 

I'm the sort of person who has trouble with the 'move fast and break things' mindset of engineering - I like to design things correctly, and sometimes I get paralyzed with indecision if I can't figure out how something ought to work. This is definitely not ideal for hobbyist game-making, where it pays to be scrappy and cobble something together 'cause that's the only way to actually have something to show for your time at the end of the day. Ah well. We pressed forward and tried to design things acceptably well, despite having little idea how anything 'ought' to be done.

Early on, we realized we were going to have to find a way to encode what the game maps would look like. I made a 'Zone' class, and a file called Zone1.java that basically functioned as data: a list of instructions to instantiate an instance of Zone that had all the objects that ought to be there - a boulder here, an ogre there, the player's character over in the center. We imagined that we could, if necessary, come up with a data format later, that we could parse to create the same objects. That would be the 'clean' way to do it, but look, we were taking shortcuts in the prototype, go us.

Pretty soon, after a bit of hand-editing these Java files, it became clear that worlds are big and that The Thing About Data is that it tends to get out of hand really quickly. Doubly so if the data is encoded in verbose Java syntax. Triply so if you find yourself changing the data format as you add new features. So we went looking for a premade level editor that would give us a visual UI for editing these worlds. This went OK.[^editor]

[^editor]: There are lots of free ones, it turns out! So this worked okay. But you run into frustrations if you want features that the editors don't support. They usually let you include arbitrary data on tiles ('height', 'light level', whatever), which lets you add features to the map, but it's a *pain* to manually edit every tile. And what if you want to support something like procedurally generated maps? Your generation code has to learn the format that the editor is using. These are solvable problems, but still.

Creating maps in an editor is a pain sometimes, though. It can be useful to be able to design a map programmatically, in an actual programming language. I'd like to be able to type out:

    for(i in [0, 99])
        for(j in [0, 99])
            map[i][j].type = Grass
            map[i][j].height = f(i, j) //some function that gives a height map

I'd also like to be able to make a map for, say, the interior of a 5x5 house, and then 'draw' it at map[37, 46], because I decided that my house should be part of a larger map instead. I'd also like to be able to draw a forest on the western side of the map, picking a random tree (Tree1, Tree2, Tree3) for each tile. Et cetera, et cetera.

This would be a pain in the Zone1.java file, for sure - you want the map to be generated once (not random every game) so you'd have to.. write code to generate Java code? That's just awful.

This would be less of a pain if you moved to a Zone1.map format, because you could write code (not necessarily in Java) to generate it once.

This would be a bit of a pain if you're using a tile editor, because you'd have to write code to generate the same output format as the editor. Not impossible, especially if it's documented.

Now suppose I change my mind, and would rather that the grass area was only in [0,49], and after that it was stone in [50, 99]? If you built the map by running ad-hoc code once, you've got to either write a new script to modify the the whole thing or to rebuild from scratch.

Suppose also that, after creating that map, I did some hand editing. I added some lava at (13, 13):

    map[13,13].type = Lava

Now if I re-build the map from the script, I've got to go add the lava again by-hand. If I even remember it was there! It was probably a month ago, and very out of my mind.

Now the problem becomes clear. What I really want is for the *actual map file* to include the code, above.

    for(i in [0, 99])
        for(j in [0, 99])
            map[i][j].type = Grass
            map[i][j].height = f(i, j)
    map[13][13].type = Lava

I'm used to being told that ["code is data"](https://en.wikipedia.org/wiki/Homoiconicity) by the Lisp camp. But how often do you realize that "data is code"?

This is going to be a trick if you write your map out in Zone1.java, because you want to be able to write *that* file with code or with a level editor, and writing your code with code is 'generally hard'. (It's very awkward in Java, but it's at least kind-of awkward in most languages.)

A little while later, I wanted to add the ability to save the game, which means saving a modified version of a zone back into a file - maybe a boulder was destroyed, maybe a character moved, maybe I added spells that can turn tiles into lava. I *definitely* want to save my world in the same format as I initially loaded it, so there's no way my world is going to be a Java class file, because I don't want to write out more Java code.

So my zone data can't be actual Java code (because it's supposed to be written by code), but it also can't be pure data (because it needs to be able to include code). Perhaps this is a job for a simple DSL?

If you went, today, to write out such a map-scripting language like this, you'd use a fully featured programming language and probably just hope the programmer doesn't make any network calls. I think that's mostly because doing anything else would be difficult, but I suspect it doesn't have to be.[^xml]

[^xml]: Or maybe you'd use a strange custom XML format, where you encode loops with \<for> tags, but you shouldn't. Seriously. Please never do this. If you find yourself writing language constructs in a data language and don't find yourself already equipped with a debugger that can step through the language you've just birthed and set breakpoints, I implore you to turn around immediately. I'm looking at you, [Ant](http://ant-contrib.sourceforge.net/tasks/tasks/). I'll never have those days of my life back. Fortunately, [lots of people](https://gradle.org/) are realizing that code should be actual code these days.

## 2

I went to make an asset in ~~Photoshop~~ Gimp for my game - a simple 8-frame animation of a burning fireball. I'm no artist, but it was easy to get an image of the quality I wanted (low. very low). I drew some red, orange, and yellow splotches, clicked around the menus until I found some transformations to swirl them together, and generated 8 different swirls from that. Then I ran a utility that I found somewhere to pack them together into a single spritesheet file, so they can be loaded as a single texture into the game engine (that's apparently more performant).

Later, suppose I wished to have a blue version of the same flames. My options for this are (well, my knowledge of these things is limited, but I *think* that they are):

* Reopen the Gimp project and change the color pallet to blues, somehow. Regenerate the spritesheet.
* Reopen the Gimp project and, finding that I applied the swirling transformations as a separate layer on top of the base red-yellow-orange sketch (something something 'layers' I don't know how they work), recolor the base sketch and watch as the swirled versions change colors as well. Regenerate the spritesheet.
* Open the spritesheet in Gimp and change the color pallet. If the transformations used had any effect on the colors, though, this could not work at all -- there's no reason `red->transform->blue` would be the same result as `blue->transform`.

God help me, though, if I want to make the color of the swirls customizable *in-game*. Oh, there are ways to do it - I can find some library that does the same sort of recolorizing operations that I'm doing in Gimp, and run it on the fly based on user-input / what spell the fireballs are being cast from. Or I could generate a bunch of different colored versions of the fireball ahead of time, though that's very inefficient space-wise. [^macro]

[^macro]: Actually, Gimp and Photoshop have macro systems. Gimp has a [batch mode](https://www.gimp.org/tutorials/Basic_Batch/), which lets you write scripts to do image editing in Lisp. That's very cool, but you would never include Gimp scripts as part of your game library.

I'm not saying it's impossible; just that it's inordinately difficult compared to the manual human workflow approach to making assets. I don't like when things are inordinately difficult. It's 2016 and we can drive cars with computers. Shouldn't everything you do on screen be *trivially* automatable?

The workflow I'm using to produce assets is sort of like a series of chained function calls, except that each function call except for the last few is executed by me:


    ColorPallet cp = ColorPallet(Red, Orange, Yellow)
    //picture 'splotchinput' as a record of my mouse motions when splotching
    Image i = DrawSplotches(cp, splotchinput)
    Image[] images = [i]*n //Pythonesque 'repeat this element 8 times'
    //picture 'swirlinput' as a list of my mouse motions on each swirl
    images = [Swirl(i, u) for i,u in zip(images, swirlinput)]
    Image spritesheet = SpriteSheet(images)
    File f = Save(spritesheet)

    //in game:
    Image spritesheet = Load(f)
    Sprite[] sprites = spritesheet.split(64,64).map(Sprite)
    Animation animation = Animation(sprites)

I'm not saying it would go exactly like this, but I am saying that I want to live in a world where code like this is *literally written out somewhere in my game*.

I want to be able to write this in my realtime game code:

    Fireball red = Fireball(Red, Yellow, Orange)
    Fireball blue = Fireball(Blue, Purple, Teal)

And have all those operations get executed to generate a second fireball with a new color pallet, even though it's inefficient.

I want to *have* the performance problem that I shouldn't be regenerating sprites in new color schemes in realtime, and have to add optimizations to precompute some common color patterns, or to add a workaround where I can recolor a base fireball template instead of having to regenerate one from the manual mouse operations each time. I want to have a compiler optimization where it realizes that it needs to optimize the whole image-building operation to optimize loading fireballs in new colors.

I want for these to be problems that it's even *possible to have*.

As far as I can tell, asset creation is a complicated programming language where the functions are all human-executed and the data is a record of your mouse clicks, that integrates with nothing, is available as a library to nobody, and can most easily be automated by recording your mouse clicks *on the UI* and playing them back without resizing the window. 

I would like this programming language to be formalized, with the graphics-programming DSL as a subset that I can invoke from within my game - if I want. Or I can go use the UI and get the result that way. Or I can use the UI, figure out what syntax in the language corresponds 1:1 to the way I used the UI, and then modify what I did that way.

Sometimes a DSL is a full language, plus an API, minus a bunch of stuff you're not allowed to do. The Firefox extension API surfaces a DSL for "what you're allowed to do to webpages from the context of a browser extension". The Greasemonkey API surfaces another one: "what you're allowed to do to webpages from inside Greasemonkey". Okay, at this point I'm totally abusing the meaning of the phrase 'DSL', but I think the point is clear. Normally you think of a DSL as a standalone language with its own simple language constructs. Instead, I encourage the view that a stripped-down or sandboxed version of a language is a DSL of sorts -- a separate language altogether.

In some sense, there's an implicit DSL being used when I interact with a UI using my mouse and keyboard. There's another implicit DSL being used when the UI interacts with the canvas. There's yet another when the UI is saving the canvas, plus my edit history, into a file. There's another when it communicates with a server. There's another when you're writing a plugin for the UI: you use the plugin DSL to inject code into the canvas-editing DSL.

I'd like to be able to write code in any of these implicit DSLs in my console, or in a file, or directly construct the AST for such a language in *another* language, and have everything work exactly the same way.

## 3

Here's a bonus image of the world's worst video game. You, the valiant adventurer, can move around and swing your axe and take on the mighty Treegnaros. Which is obviously just a... tree version... of Ragnaros from World of Warcraft. He throws fireballs and taunts you and dies when you hit him a lot.

{% include image.html filename="2016-11-10-dsls/treegnaros.png" width="75%" %}

Yeah. Turns out we lost interest after getting to this, um, 'minimum viable product'.