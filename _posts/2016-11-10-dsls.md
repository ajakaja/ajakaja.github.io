---
layout: blog
title: "DSLs all the way down"
math: true
footnotes: true
excerpt_separator: <!--more-->
---

*[possibly interesting to: software engineers]*  
*[epistemic status: rant, so possibly a good idea but borne of frustration. There are likely arguments against it that experience hasn't taught me yet.]*
{: style="text-indent: 0em"}

A [Domain-Specific Language](https://en.wikipedia.org/wiki/Domain-specific_language), or DSL, is a mini-programming language created for a specific purpose, rather than being generally useful for doing anything. HTML is the most well-known example: it's used to write webpages. It's not used to write servers or databases, because it's a declarative content organization language and it just can't really do that.

Now, here are two anecdotes about how software engineering is hard.
{: style="text-indent: 0em"}

<!--more-->

## 1. Mapmaking

Once upon a time, a friend and I embarked on a journey to write a little video game, in Java because that's what we knew best. It was to be a simple tile-based RPG, with combat, spellcasting, exploration, dialogue, AI, etc. 

We came upon the problem of describing a game map in a file. I made a 'Zone' class, and a file called Zone1.java that basically functioned as data: lines of code to instantiate an instance of Zone and objects for everything within it (a boulder here, an ogre there, the player's character over in the center). We figured an actual data format could come later, along with a parser that took the file as input and gave the same Java objects as result. For now, we were taking shortcuts in the prototype, go us.

After a bit of hand-editing these Java files, it became clear that worlds are big and that The Thing About Data is that it tends to get out of hand really quickly. Doubly so if the data is encoded in verbose Java syntax; triply so if you find yourself changing the data format as you add new features, and having to go back and convert the format of the maps you've already made. So we went looking for a premade level editor that would give us a UI for world-editing and a map file format for storage. This went okay.[^editor]

[^editor]: There are lots of free ones, it turns out -- but you run into frustrations if you want features that the editors don't support. They usually let you include arbitrary data on tiles ('height', 'light level', whatever), which lets you add features to the map, but it can be a *pain* to manually edit every tile. And what if you want to support something like procedurally generated maps? Your generation code has to learn the format that the editor is using.

Creating maps in an editor isn't always ideal, though. There were some niceties about getting to do it in source code. Sometimes it's easier, when trying to set up a large area, to just be able to write something like:

{% highlight java %}
for(i in [0, 99])
    for(j in [0, 99])
        map[i][j].type = Grass
        map[i][j].height = f(i, j) //some function that gives a height map
{% endhighlight %}

Also useful is that you can make a map for, say, the interior of a 5x5 house, and then 'draw' it at map[37, 46], when later you decide that the house should be part of a larger map. And it's nice to be able to draw a forest on the western side of the map, picking a random tree (Tree1, Tree2, Tree3) for each tile. Et cetera, et cetera.

So on the one hand it's useful to be able to generate maps in code. But you also want to save the results of those generation statically - if you were creating a map using, say, the random tree example above, you would still want the map to be the same every time the game is run. Your options are to use a specific seed so the result is always the same, or to save the results of one run into a file.

On the other hand, a level editor is *also* useful, because managing large amounts of data stored in text that's supposed to correspond to visual output is time-consuming. (It's still possible to write code to create maps, outputting whatever format the editor uses for its file. Not impossible, especially if it's documented.)

The game will also require the ability to save progress, which means writing a modified version of a zone back into a file. Maybe a boulder was destroyed, maybe a character moved, maybe some spells have been cast that turned certain tiles into lava. I *definitely* want to save my world in the same format as I initially loaded it, so there's no way my world is going to be a Java class file because this format is also being written at runtime.

The question is:
{: style="text-indent: 0em"}
* Should the map file contain the raw data that's the result of 'running my map-building script, plus any subsequent edits' (option 1)? 
* Or should it contain the map-building script itself, to be re-run at any time (option 2)?

Suppose you change your mind and prefer that the grass area is only in [0,49], and after that it's stone from [50, 99]. But you may have made modifications after setting up the grass. Maybe you added some lava:

    map[13,13].type = Lava

If the map was built by running a script and then some hand-editing (option 1), you've got to either write a new script to modify the the whole thing or to rebuild from scratch, including remembering to add the lava again - if you even remember it was there! It was probably a month ago, and very out of mind. 

If the map is continuously built from a script (option 2), then the lava-edit must have been added to that script too - but map editors don't customarily do that; they destructively modify data files.

I want to be able to doodle maps in a visual editor, but still get as output a map file with code:

{% highlight java %}
for(i in [0, 99])
    for(j in [0, 99])
        map[i][j].type = Grass
        map[i][j].height = f(i, j)
map[13][13].type = Lava
{% endhighlight %}

And then my map editor's output, when I make changes, is more lines of this type of code appended to the end of the file. Also, if the map file can be updated by appending, we have the attractive option of saving progress by storing only a 'diff' to the map -- useful if save files get very large.

This map format would let a developer:
{: style="text-indent: 0em"}
* write maps by hand-editing the file
* write maps from my game's source code (emitting lines of the simple syntax used in the file)
* write maps from my console
* draw maps from an editor
* compress maps to their raw output at release time, if that's useful

I'm used to hearing that ["code is data"](https://en.wikipedia.org/wiki/Homoiconicity) from Lisp users. But how often do you get "data should be code"?
{: style="text-indent: 0em"}

It's not going to work if you design your maps in the game's source code, like in Zone1.java, because you want to be able to write *that* file with code or with a level editor, and writing your code with code is 'generally hard'. (Well, it's very awkward in Java, but it's at least kind of awkward in most languages.)

So zone data can't be actual source code (because it's supposed to be written by source code), but can't be pure data (because it needs to be able to include something like code). Perhaps this is a job for a simple DSL?[^xml] But DSLs aren't commonly found in a game developer's toolbox. And they're rumored to be [perilous](https://gamedev.stackexchange.com/questions/560/domain-specific-languages-for-scripting). And how strong of a language would I need?

[^xml]: Or maybe you'd use a strange custom XML format, where you encode loops with \<for> tags, but you shouldn't. Seriously, please. If you find yourself writing language constructs in a data language and don't find yourself already equipped with a debugger that can step through the language you've just birthed and set breakpoints, I implore you to turn around immediately. I'm looking at you, [Ant](http://ant-contrib.sourceforge.net/tasks/tasks/). I'll never have those days of my life back. Fortunately, [lots of people](https://gradle.org/) are realizing that XML should not used as code these days.

## 2. Artmaking

I went to make an asset in ~~Photoshop~~ Gimp for our game: a simple 8-frame animation of a burning fireball. I'm no artist, but it was easy to get an image of the quality I wanted (low. very low). I drew some red, orange, and yellow splotches, clicked around the menus until I found some transformations to swirl them together, and generated 8 different swirls from that. Then I ran a utility that I found somewhere to pack them together into a single spritesheet file, so they can be loaded as a single texture into the game engine -- that's apparently more performant.

What am I to do, later, when I need a blue version of the same flames? My options are:

* Reopen the Gimp project and change the color pallet to blues, somehow. Regenerate the spritesheet.
* Reopen the Gimp project and, finding that I applied the swirling transformations as a separate layer on top of the base red-yellow-orange sketch (if that's possible..), recolor the base sketch and watch as the swirled versions change colors as well. Regenerate the spritesheet.
* Open the spritesheet in Gimp and change the color pallet. If the transformations used had any effect on the colors, though, this could not work at all -- there's no reason `red->transform->blue` would be the same result as `blue->transform`.
* Programmatically change the spritesheet to a new color scheme at load or call time, using a graphic library from my game code. This is the only way that's going to get let me customize the color scheme in-game.

It's not impossible, but it's inordinately difficult compared to the manual human workflow approach to making assets. I don't like when things are inordinately difficult. It's 2016 and we can drive cars with computers. Shouldn't everything you do on screen be *trivially* automatable?[^macro]

[^macro]: Gimp and Photoshop do have macro systems. Gimp has a [batch mode](https://www.gimp.org/tutorials/Basic_Batch/), which lets you write scripts to do image editing in Lisp. That's very cool, but you would never include Gimp scripts as part of your game library. And this can only cover the image-editing part of the pipeline, even in the best case.

The workflow I'm using to produce assets is sort of like a series of chained function calls, except that most of them are executed by me:

{% highlight java %}
// human code:
ColorPallet cp = ColorPallet(Red, Orange, Yellow)
// picture 'splotchinput' as a record of my mouse motions when splotching
Image i = DrawSplotches(cp, splotchinput)
Image[] images = [i]*8 // Pythonesque 'repeat this element n times'
// picture 'swirlinput' as a list of my mouse motions on each swirl
images = [Swirl(i, u) for i,u in zip(images, swirlinput)]
Image spritesheet = SpriteSheet(images)
File f = Save(spritesheet)

// game code:
Image spritesheet = Load(f)
Sprite[] sprites = spritesheet.split(64,64).map(Sprite)
Animation animation = Animation(sprites)
{% endhighlight %}

I'd like to live in a world where code like this can be *literally written out somewhere*.
{: style="text-indent: 0em"}

Perhaps I'd be able to write this in my realtime game code:
{: style="text-indent: 0em"}

{% highlight java %}
Fireball red = Fireball(Red, Yellow, Orange)
Fireball blue = Fireball(Blue, Purple, Teal)
{% endhighlight %}

and have all the above instructions get executed to generate a second fireball with a new color pallet, even though it's inefficient.
{: style="text-indent: 0em"}

I want to *have* the performance problem that I shouldn't be regenerating sprites in new color schemes in realtime, and have to add optimizations to precompute some common color patterns, or to add a workaround where I can recolor a base fireball template instead of having to regenerate one from the manual mouse operations each time. And for there to be compiler optimization where it realizes that it needs to optimize the whole image-building operation to optimize loading fireballs in new colors.

I want these to be problems that it's even *possible* to have.
{: style="text-indent: 0em"}

## 2.9 Bonus Section

Here's a screenshot of the world's worst video game. You, the valiant adventurer, can move around and swing your axe and take on the mighty Treegnaros. Which is obviously just a... tree version... of Ragnaros from World of Warcraft. He throws fireballs and taunts you and dies when you hit him with your axe a lot.

{% include image.html filename="2016-11-10-dsls/treegnaros.png" width="75%" %}

We lost interest after getting to this, uh, 'minimum viable product'. Learned a ton from the process, though. Clearly enough to write a ranty blog post, at least, and in fact a lot more than that.

(If you want to make a game but suspect you don't have the time or energy to finish, you should do it anyway. It's the first day/week/month of work that's packed with lessons, and even if you quit, doing it again in the future will feel much more palatable because you've already fought the nebulous battles that make starting seem scary and imposing. Trying once cuts the 'activation willpower' of doing it again by at least half.)

## 3. DSL everything

As far as I can tell, map-creation for a tile-based game is a process better suited for a minimal programming language, so that I can express ideas in whatever format is most natural: not just running code, but also not just drawing; some mix of the too. But making a simple language myself is a daunting task, because the languages I know aren't fluent at that. 

There are DSL toolsets, such as [this](https://www.jetbrains.com/mps/) offering from Jetbrains, which I now think have the right idea - but until I got down this train of thought I would have never considered incorporating one into a game. It used to be easier to suffer. Now I think it's actually easier to integrate one, or start working on my own library. Content-creation, after the initial engine, is the biggest burden that prevents me from taking my game prototypes to full-fledged games, because after the first few areas and AI scripts the job of fleshing out a whole world starts to feel overwhelming. A big part of this is the lack of efficient tooling.

----------

Meanwhile, as far as I can tell, asset creation is a complicated *implicit* programming language where the functions are all human-executed and the data is a record of your mouse clicks, that integrates with nothing, is available as a library to nobody, and can most easily be automated by recording your mouse clicks *on the UI* and playing them back without resizing the window.

This 'programming language' could be formalized, with the graphics-programming DSL as a sublanguage that I can invoke from within my game - if I want. Or I can go use the UI and get the result that way. Or I can use the UI, figure out what syntax in the language corresponds 1:1 to the way I used the UI, and then modify what I did to do it programmatically next time.

In a sense, there's an implicit DSL being used when I interact with a UI using my mouse and keyboard. There's another implicit DSL being used when the UI interacts with the canvas. There's yet another when the UI is saving the canvas, plus my edit history, into a file. There's another when it communicates with a server. There's another when you're writing a plugin for the UI: you use the plugin DSL to inject code into the canvas-editing DSL. It's *DSLs all the way down*.[^abuse]

[^abuse]: well, yes, at this point the term 'DSL' is a bit out of its comfort zone.

-------

I'd like to be able to write code in any of these DSLs in my console, or in a file, or directly construct the AST for such a language in *another* language, and have everything work exactly the same way. I'd like to be able to record the results of my actions at a certain level within the application, see how they worked, and then make changes to the record and play it again to see how the result changes.

Today these DSLs are either implicit (human-executed, with no isomorphism to source code), or they're baked into the same application codebase and inaccessible without going into the source. I don't expect to be able to easily automate operations at the level of the language that the application uses to interact with the canvas, because I have to dig into the internals of the application do so -- even though my UI interactions correspond cleanly to the execution of instructions at that level.

Sometimes a DSL is a full language, plus an API, minus a bunch of stuff you're not allowed to do. The Firefox extension API surfaces a DSL for "what you're allowed to do to webpages from the context of a browser extension". The Greasemonkey API surfaces another one: "what you're allowed to do to webpages from inside Greasemonkey". Normally you think of a DSL as a standalone language with its own simple language constructs. Instead, I like the view that a stripped-down or sandboxed version of a language is a DSL of sorts -- a separate language altogether. We've stepped away from the precise usual definition of the term, but I don't know a better one.

We've built ourselves a technology ecosystem where things are either easily integrated with code or strictly not, and rarely does anything cross the line. Drawing and design are the domain of humans and you'd never code against those; business logic is the domain of code and you'd never (or at least rarely) write it out in a high-level language that prevents you from making obvious mistakes (unless you're an enterprise developer and [the system has gotten so complicated that management actually OKs that](https://stackoverflow.com/questions/206425/has-a-system-that-incorporated-a-rule-engine-ever-been-truly-successful?rq=1)). In many cases there's not a lot of difference between a series of API calls and code in a minimally-featured language -- but you can't debug or type-check API calls at the fluent, business-logic level; you have to work with them at the level of the language you're invoking them from.

In practice everything we do from manual action to API calls corresponds to actions in a hand-wavey language of some sort. In many cases it might actually be easier to formalize that language as a simple DSL -- especially if was mentally cheaper to do so -- so as to get 'type safety', debuggability, replayability, and other benefits, without conflating that logical code with lower-level application code. I haven't figured out the cleanest, cheapest, least-*"this was actually a huge mistake but it took three months to tell"* way to do this, but I hope to.